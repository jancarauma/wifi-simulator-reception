<!--
  WiFi‑Reception-Sim
  © 2025 Janderson G. da Silva
  Repository: https://github.com/jancarauma/wifi-reception-simulator
  "artientista.blogspot.com"

  Licensed under the MIT License.
  You may obtain a copy of the License at:
  https://opensource.org/licenses/MIT

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is furnished
  to do so, subject to the following conditions:

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Reception Simulator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #3498db;
            --primary-dark: #2980b9;
            --secondary: #9b59b6;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --gray: #95a5a6;
            --background: #1a1a2e;
            --card-bg: #16213e;
            --text: #e6e6e6;
            --text-secondary: #b3b3b3;
            --router-colors: ['#00FF00', '#FF0000', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
        }

        [data-theme="light"] {
            --background: #f5f7fa;
            --card-bg: #ffffff;
            --text: #2c3e50;
            --text-secondary: #7f8c8d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            background: var(--background);
            min-height: 100vh;
            padding: 20px;
            color: var(--text);
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--card-bg);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        }

        header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-content {
            flex: 1;
            min-width: 300px;
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .theme-toggle {
            background: var(--card-bg);
            border: 2px solid var(--primary);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }

        .theme-toggle:hover {
            background: var(--primary);
            color: white;
        }

        .instructions {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(155, 89, 182, 0.2));
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid var(--primary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .instructions h3 {
            margin-top: 0;
            color: var(--primary);
            font-size: 1.4rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instructions ul {
            margin-bottom: 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 12px;
        }

        .instructions li {
            margin-bottom: 8px;
            color: var(--text);
            padding-left: 10px;
            border-left: 3px solid var(--primary);
            padding: 8px 0 8px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0 8px 8px 0;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 18px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: var(--text);
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        select, button, input {
            padding: 12px 16px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.25);
        }

        button {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(52, 152, 219, 0.4);
        }

        button:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--secondary), #8e44ad);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #27ae60);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning), #e67e22);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #c0392b);
        }

        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 8px;
        }

        .tool-buttons button {
            padding: 10px;
            font-size: 0.9rem;
        }

        .simulation-area {
            display: flex;
            gap: 25px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .canvas-container {
            flex: 1;
            min-width: 700px;
            background: var(--card-bg);
            border-radius: 18px;
            padding: 15px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            min-height: 650px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .canvas-container::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--warning), var(--success));
            border-radius: 20px;
            z-index: -1;
            animation: gradient-border 8s ease infinite;
            background-size: 400% 400%;
        }

        @keyframes gradient-border {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        canvas {
            border-radius: 12px;
            cursor: crosshair;
            display: block;
            max-width: 100%;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .panel-container {
            display: flex;
            flex-direction: column;
            gap: 25px;
            width: 400px;
        }

        .info-panel {
            padding: 25px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 18px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            flex: 1;
        }

        .legend {
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        .legend h3 {
            margin-bottom: 18px;
            color: var(--primary);
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 15px;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .legend-color {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            margin-right: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        .stats {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            margin-top: 20px;
        }

        .stats h3 {
            margin-bottom: 18px;
            color: var(--primary);
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 15px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-value {
            font-weight: 600;
            color: var(--primary);
        }

        .zoom-controls {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .zoom-controls button {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            padding: 0;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cursor-position {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-secondary);
            flex-wrap: wrap;
            gap: 10px;
        }

        .tool-active {
            background: linear-gradient(135deg, var(--success), #27ae60) !important;
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.4) !important;
        }

        .router-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
        }
        
        .router-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
        }
        
        .router-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .router-item.active {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid var(--primary);
        }
        
        .router-item .actions {
            display: flex;
            gap: 5px;
        }
        
        .router-item .actions button {
            padding: 5px 8px;
            font-size: 12px;
        }
        
        .speed-legend {
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .dead-zone-list {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
        }

        .dead-zone-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 5px;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 1.8rem;
            color: var(--primary);
        }
        
        .close-modal {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .history-item {
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
        }
        
        .history-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .channel-selector {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .channel-btn {
            padding: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            text-align: center;
        }
        
        .channel-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        
        .tool-preview {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            display: none;
        }
        
        .distance-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 15;
        }
        
        .measure-line {
            position: absolute;
            background: rgba(255, 255, 0, 0.5);
            height: 2px;
            transform-origin: 0 0;
            z-index: 10;
        }
        
        .tool-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: none;
        }

        @media (max-width: 1400px) {
            .simulation-area {
                flex-direction: column;
            }
            
            .panel-container {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .info-panel {
                width: calc(50% - 12px);
            }
        }
        
        @media (max-width: 900px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .tool-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .canvas-container {
                min-width: 100%;
                min-height: 500px;
            }
            
            .info-panel {
                width: 100%;
            }
        }
        
        @media (max-width: 600px) {
            .header-content {
                min-width: 100%;
            }
            
            .theme-toggle {
                width: 100%;
                justify-content: center;
            }
            
            .tool-buttons button span {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <h1><i class="fas fa-wifi"></i>&nbsp;WiFi Simulator</h1>
                <p class="subtitle">WiFi signal reception in environments with different materials and multiple routers.</p>
                <p class="subtitle">by J. Caraumã</p>
            </div>
            <button class="theme-toggle" id="themeToggle">
                <i class="fas fa-moon"></i>
            </button>
        </header>        

        <div class="controls">
            <div class="control-group">
                <label><i class="fas fa-tools"></i> Tools:</label>
                <div class="tool-buttons">
                    <button id="tool-wall" class="tool-active"><i class="fas fa-wall"></i> <span>Wall</span></button>
                    <button id="tool-erase"><i class="fas fa-eraser"></i> <span></span></button>
                    <button id="tool-rect"><i class="fas fa-vector-square"></i> <span></span></button>
                    <button id="tool-router"><i class="fas fa-wifi"></i> <span></span></button>
                    <button id="tool-paint"><i class="fas fa-fill-drip"></i> <span></span></button>
                    <button id="tool-measure"><i class="fas fa-ruler"></i> <span></span></button>
                </div>
            </div>

            <div class="control-group">
                <label><i class="fas fa-sliders-h"></i> Animation Controls:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="playPause"><i class="fas fa-play"></i></button>
                    <button id="reset"><i class="fas fa-redo"></i></button>                    
                    <button id="saveImage" class="btn-success"><i class="fas fa-camera"></i> Save as PNG</button>
                </div>
            </div>
            
            <div class="control-group">
                <label><i class="fas fa-project-diagram"></i> Project:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="saveLayout" class="btn-secondary"><i class="fas fa-save"></i></button>
                    <button id="loadLayout" class="btn-secondary"><i class="fas fa-folder-open"></i></button>
                    <button id="undoBtn"><i class="fas fa-undo"></i></button>
                    <button id="redoBtn"><i class="fas fa-redo"></i></button>
                    <button id="historyBtn" class="btn-warning"><i class="fas fa-history"></i></button>
                    <button id="loadExample"><i class="fas fa-home"></i> Example</button>
                </div>
            </div>
            
            <div class="control-group">                
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <label><i class="fas fa-paint-roller"></i> Materials (transmission):</label>
                <select id="wallMaterial" style="background: var(--primary)">
                    <option value="drywall"><i class="fas fa-home"></i> Drywall (92%)</option>
                    <option value="concrete"><i class="fas fa-border-style"></i> Concrete (60%)</option>
                    <option value="wood"><i class="fas fa-tree"></i> Wood (80%)</option>
                    <option value="brick" selected><i class="fas fa-cubes"></i> Brick (70%)</option>
                    <option value="glass"><i class="fas fa-window-maximize"></i> Glass (85%)</option>
                </select>
                <label><i class="fas fa-ruler-combined"></i> Material Thickness:</label>
                <input type="range" id="wallThickness" min="1" max="5" step="1" value="3">
                <span id="thicknessValue">3px</span>
                </div>
            </div>
            
            <div class="control-group">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <label><i class="fas fa-satellite-dish"></i> Frequency:</label>
                <select id="frequency" style="background: var(--primary)">
                    <option value="0.02">2.4 GHz (long range)</option>
                    <option value="0.05" selected>5.0 GHz (medium range)</option>
                    <option value="0.08">6.0 GHz (short range)</option>
                </select>
                <label><i class="fas fa-bolt"></i> Router Power:</label>
                <input type="range" id="power" min="0.5" max="2.0" step="0.1" value="1.0">
                <span id="powerValue">1.0</span>
                </div>
            </div>
                        
        </div>

        <div class="simulation-area">
            
            <div class="canvas-container">
                <div class="zoom-controls">
                    <button id="zoomIn"><i class="fas fa-search-plus"></i></button>
                    <button id="zoomOut"><i class="fas fa-search-minus"></i></button>
                    <button id="resetZoom"><i class="fas fa-sync-alt"></i></button>
                </div>
                <div class="cursor-position">Position: (0, 0)</div>
                <div class="tool-info" id="toolInfo">Tip: Click to start measuring</div>
                <div class="tool-preview" id="toolPreview"></div>
                <canvas id="simulationCanvas" width="1024" height="800"></canvas>                
            </div>            
            
            <div class="panel-container">
                <div class="info-panel">
                                                            
                    <div class="router-control">
                        <h3><i class="fas fa-wifi"></i> Routers</h3>
                        <div style="padding: 8px"><button id="addRouter"><i class="fas fa-plus"></i> Adicionar Roteador</button></div>
                        <div class="router-list" id="routerList">
                            <!-- Lista de roteadores -->
                        </div>
                    </div>
                    
                    <div class="channel-control" style="padding-top: 20px">
                        <h3><i class="fas fa-broadcast-tower"></i> WiFi Channel(s)</h3>
                        <div style="padding: 8px"><div class="channel-selector">
                            <div class="channel-btn active" data-channel="1">1</div>
                            <div class="channel-btn" data-channel="6">6</div>
                            <div class="channel-btn" data-channel="11">11</div>
                            <div class="channel-btn" data-channel="36">36</div>
                            <div class="channel-btn" data-channel="149">149</div>
                        </div></div>
                    </div>
                    
                </div>
                
                <div class="info-panel">
                    <div class="stats">
                        <h3><i class="fas fa-chart-bar"></i> Statistics:</h3>
                        <div class="stat-item">
                            <span>Time of simulation:</span>
                            <span id="timeStep" class="stat-value">0</span>
                        </div>
                        <div class="stat-item">
                            <span>FPS:</span>
                            <span id="fps" class="stat-value">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Signal Coverage:</span>
                            <span id="coverage" class="stat-value">0%</span>
                        </div>
                        <div class="stat-item">
                            <span>Average Speed:</span>
                            <span id="avgSpeed" class="stat-value">0 Mbps</span>
                        </div>
                        <div class="stat-item">
                            <span>Max Speed:</span>
                            <span id="maxSpeed" class="stat-value">0 Mbps</span>
                        </div>
                        <div class="stat-item">
                            <span>Dead Zones:</span>
                            <span id="deadZones" class="stat-value">0%</span>
                        </div>
                        <div class="stat-item">
                            <span>Router Count:</span>
                            <span id="routerCount" class="stat-value">0</span>
                        </div>
                    </div>
                    
                    <div class="dead-zones" style="padding-top: 20px">
                        <h3><i class="fas fa-exclamation-triangle"></i> Zonas Mortas</h3>
                        <div class="dead-zone-list" id="deadZoneList">
                            <!-- Lista de zonas mortas -->
                        </div>
                    </div>
                    
                    <div class="speed-legend">
                        <h4><i class="fas fa-tachometer-alt"></i> Speed:</h4>
                        <div>0 Mbps → 100 Mbps → 500 Mbps → 1000+ Mbps</div>
                        <div style="height: 10px; background: linear-gradient(to right, #4b0082, #9370db, #ffd700); border-radius: 5px; margin-top: 5px;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div>Tool: <span id="current-tool">Wall</span></div>
            <div>Material: <span id="current-material">Drywall</span></div>
            <div>Thickness: <span id="current-thickness">3px</span></div>
            <div>Channel: <span id="current-channel">1</span></div>
        </div>

        <div class="legend" style="padding-top: 20px">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #000;"></div>
                            <span>Air</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #8B4513;"></div>
                            <span>Drywall (92%)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #696969;"></div>
                            <span>Concrete (60%)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #A0522D;"></div>
                            <span>Wood (80%)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #CD5C5C;"></div>
                            <span>Brick (70%)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #87CEEB;"></div>
                            <span>Glass (85%)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(to right, #4b0082, #9370db, #ffd700);"></div>
                            <span>Signal Speed (slow to fast)</span>
                        </div>
                    </div>

        <div class="instructions" style="margin-top: 20px">
            <h3><i class="fas fa-info-circle"></i> How to Use:</h3>
            <ul>
            <li><strong>Wall Tool:</strong> Click and drag to add walls with the selected material.</li>
            <li><strong>Paint Tool:</strong> Click on existing walls to change their material.</li>
            <li><strong>Measure Tool:</strong> Click and drag to measure distances.</li>
            <li><strong>Router Tool:</strong> Click to position the WiFi router (drag to move).</li>
            <li><strong>Zoom:</strong> Use the zoom buttons or the mouse wheel to zoom in/out.</li>
            <li><strong>Play/Pause:</strong> Start/pause the signal propagation simulation.</li>
            <li><strong>Multiple Routers:</strong> Add multiple routers to simulate mesh networks.</li>
            <li><strong>Speed Analysis:</strong> View the estimated speed on each period.</li> <li><strong>Channel Selector:</strong> Choose WiFi channels to minimize interference.</li>
            </ul>
        </div>
    </div>
    
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title"><i class="fas fa-history"></i> Histórico de Simulação</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div id="historyList">
                <!-- Histórico -->
            </div>
        </div>
    </div>

    <script>
        class WiFiSimulator {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Parâmetros iniciais
                this.Nx = 160;
                this.Ny = 160;
                this.dx = this.width / this.Nx;
                this.dy = this.height / this.Ny;
                this.c = 1.0;
                this.dt = 0.4 * Math.min(this.dx, this.dy) / this.c;
                
                // Campos eletromagnéticos
                this.Ez = new Array(this.Nx).fill().map(() => new Array(this.Ny).fill(0));
                this.Hx = new Array(this.Nx).fill().map(() => new Array(this.Ny - 1).fill(0));
                this.Hy = new Array(this.Nx - 1).fill().map(() => new Array(this.Ny).fill(0));
                
                // Ambiente
                this.walls = new Array(this.Nx).fill().map(() => new Array(this.Ny).fill(false));
                this.wallMaterial = new Array(this.Nx).fill().map(() => new Array(this.Ny).fill(0));
                
                // Roteadores
                this.routers = []; // Array de roteadores: {x, y, frequency, power, color}
                this.selectedRouterIndex = -1; // Índice do roteador selecionado na lista
                
                // Propriedades dos materiais para WiFi
                this.materials = {
                    air: { name: "Air", color: "#000000", absorption: 0.0, reflection: 0.0, transmission: 1.0 },
                    drywall: { name: "Drywall", color: "#8B4513", absorption: 0.03, reflection: 0.05, transmission: 0.92 },
                    concrete: { name: "Concrete", color: "#696969", absorption: 0.15, reflection: 0.25, transmission: 0.60 },
                    wood: { name: "Wood", color: "#A0522D", absorption: 0.08, reflection: 0.12, transmission: 0.80 },
                    brick: { name: "Brick", color: "#CD5C5C", absorption: 0.10, reflection: 0.20, transmission: 0.70 },
                    glass: { name: "Glass", color: "#87CEEB", absorption: 0.05, reflection: 0.10, transmission: 0.85 }
                };
                
                // Coeficientes de atualização
                this.cezh = this.dt / this.dx;
                this.cezhy = this.dt / this.dy;
                this.chxe = this.dt / this.dy;
                this.chye = this.dt / this.dx;
                
                // Controles
                this.running = false;
                this.timeStep = 0;
                this.frequency = 0.05;
                this.power = 1.0;
                this.currentWallMaterial = 'drywall';
                this.wallThickness = 3;
                this.currentTool = 'wall';
                this.currentChannel = 1;
                
                // Ferramenta retângulo
                this.rectStart = null;
                this.isDrawingRect = false;
                
                // Zoom
                this.zoomLevel = 1.0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.dragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                
                // Histórico para undo/redo
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 20;
                
                // Histórico de simulações
                this.simulationHistory = JSON.parse(localStorage.getItem('wifiSimHistory')) || [];
                
                // Performance
                this.lastTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                
                // Zonas mortas
                this.deadZones = [];
                
                // Medição
                this.measureStart = null;
                this.measureEnd = null;
                this.measureLine = null;
                this.measureDistance = null;
                
                // Arrastar roteadores
                this.draggingRouter = null;
                
                // Otimização de renderização
                this.imageData = null;
                this.needsRedraw = true;
                this.lastRender = 0;
                this.renderInterval = 1000 / 30; // 30 FPS
                
                this.setupEventListeners();
                this.initialize();
            }
            
            initialize() {
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.imageData = this.ctx.createImageData(this.width, this.height);
                this.draw();
            }
            
            setupEventListeners() {
                // Canvas eventos
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.handleMouseWheel.bind(this), { passive: false });
                
                // Controles
                document.getElementById('playPause').addEventListener('click', () => {
                    this.toggleSimulation();
                });
                
                document.getElementById('reset').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('loadExample').addEventListener('click', () => {
                    this.loadExampleApartment();
                });
                
                document.getElementById('saveImage').addEventListener('click', () => {
                    this.saveAsImage();
                });
                
                document.getElementById('frequency').addEventListener('change', (e) => {
                    this.frequency = parseFloat(e.target.value);
                });
                
                document.getElementById('power').addEventListener('input', (e) => {
                    this.power = parseFloat(e.target.value);
                    document.getElementById('powerValue').textContent = this.power.toFixed(1);
                });
                
                document.getElementById('wallMaterial').addEventListener('change', (e) => {
                    this.currentWallMaterial = e.target.value;
                    document.getElementById('current-material').textContent = 
                        this.materials[this.currentWallMaterial].name;
                });
                
                document.getElementById('wallThickness').addEventListener('input', (e) => {
                    this.wallThickness = parseInt(e.target.value);
                    document.getElementById('thicknessValue').textContent = this.wallThickness + 'px';
                    document.getElementById('current-thickness').textContent = this.wallThickness + 'px';
                });
                
                // Ferramentas
                document.getElementById('tool-wall').addEventListener('click', () => {
                    this.setTool('wall');
                    this.hideToolInfo();
                });
                
                document.getElementById('tool-erase').addEventListener('click', () => {
                    this.setTool('erase');
                    this.hideToolInfo();
                });
                
                document.getElementById('tool-rect').addEventListener('click', () => {
                    this.setTool('rect');
                    this.hideToolInfo();
                });
                
                document.getElementById('tool-router').addEventListener('click', () => {
                    this.setTool('router');
                    this.hideToolInfo();
                });
                
                document.getElementById('tool-paint').addEventListener('click', () => {
                    this.setTool('paint');
                    this.hideToolInfo();
                });
                
                document.getElementById('tool-measure').addEventListener('click', () => {
                    this.setTool('measure');
                    this.showToolInfo("Clique para iniciar a medição");
                });
                
                // Zoom
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.zoom(1.2);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.zoom(0.8);
                });
                
                document.getElementById('resetZoom').addEventListener('click', () => {
                    this.zoomLevel = 1.0;
                    this.offsetX = 0;
                    this.offsetY = 0;
                    this.needsRedraw = true;
                });
                
                // Salvar/Carregar
                document.getElementById('saveLayout').addEventListener('click', () => {
                    this.saveLayout();
                });
                
                document.getElementById('loadLayout').addEventListener('click', () => {
                    this.loadLayout();
                });
                
                // Undo/Redo
                document.getElementById('undoBtn').addEventListener('click', () => {
                    this.undo();
                });
                
                document.getElementById('redoBtn').addEventListener('click', () => {
                    this.redo();
                });
                
                // Histórico
                document.getElementById('historyBtn').addEventListener('click', () => {
                    this.showHistory();
                });
                
                // Adicionar roteador
                document.getElementById('addRouter').addEventListener('click', () => {
                    this.setTool('router');
                });
                
                // Canais WiFi
                document.querySelectorAll('.channel-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.currentChannel = parseInt(e.target.dataset.channel);
                        document.querySelectorAll('.channel-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        document.getElementById('current-channel').textContent = this.currentChannel;
                        this.showToast(`WiFi channel changed to ${this.currentChannel}`);
                    });
                });
                
                // Tema
                document.getElementById('themeToggle').addEventListener('click', () => {
                    this.toggleTheme();
                });
                
                // Fechar modal
                document.querySelector('.close-modal').addEventListener('click', () => {
                    document.getElementById('historyModal').style.display = 'none';
                });
                
                // Atualizar status inicial
                document.getElementById('current-tool').textContent = 'Wall';
                document.getElementById('current-material').textContent = 'Drywall';
                document.getElementById('current-thickness').textContent = this.wallThickness + 'px';
                document.getElementById('current-channel').textContent = this.currentChannel;
                
                // Resize debounce
                window.addEventListener('resize', () => {
                    clearTimeout(this.resizeTimer);
                    this.resizeTimer = setTimeout(() => {
                        this.canvas.width = this.canvas.offsetWidth;
                        this.canvas.height = this.canvas.offsetHeight;
                        this.needsRedraw = true;
                    }, 200);
                });
            }
            
            setTool(tool) {
                this.currentTool = tool;
                
                // Atualiza botões
                document.querySelectorAll('.tool-buttons button').forEach(btn => {
                    btn.classList.remove('tool-active');
                });
                document.getElementById(`tool-${tool}`).classList.add('tool-active');
                
                // Atualiza status
                const toolNames = {
                    'wall': 'Wall',
                    'erase': 'Erase',
                    'rect': 'Rectangle',
                    'router': 'Router',
                    'paint': 'Change Material',
                    'measure': 'Measure'
                };
                document.getElementById('current-tool').textContent = toolNames[tool];
                
                // Limpa medição
                if (tool !== 'measure') {
                    this.clearMeasurement();
                }
            }
            
            showToolInfo(message) {
                const toolInfo = document.getElementById('toolInfo');
                toolInfo.textContent = message;
                toolInfo.style.display = 'block';
            }
            
            hideToolInfo() {
                document.getElementById('toolInfo').style.display = 'none';
            }
            
            addRouter(x, y) {
                const colors = ['#00FF00', '#FF0000', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
                const color = colors[this.routers.length % colors.length];
                
                this.routers.push({
                    x: x,
                    y: y,
                    frequency: 0.05, // Frequência padrão 5 GHz
                    power: 1.0,      // Potência padrão
                    color: color
                });
                
                this.selectedRouterIndex = this.routers.length - 1;
                this.updateRouterList();
                this.reset();
            }
            
            updateRouterList() {
                const routerList = document.getElementById('routerList');
                routerList.innerHTML = '';
                
                this.routers.forEach((router, index) => {
                    const routerItem = document.createElement('div');
                    routerItem.className = `router-item ${index === this.selectedRouterIndex ? 'active' : ''}`;
                    routerItem.innerHTML = `
                        <div>Roteador ${index + 1}</div>
                        <div class="actions">
                            <button class="edit-router" data-index="${index}"><i class="fas fa-edit"></i></button>
                            <button class="remove-router" data-index="${index}"><i class="fas fa-trash"></i></button>
                        </div>
                    `;
                    routerList.appendChild(routerItem);
                });
                
                document.getElementById('routerCount').textContent = this.routers.length;
                
                // Adiciona event listeners para os botões
                document.querySelectorAll('.remove-router').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const index = parseInt(e.target.closest('button').dataset.index);
                        this.removeRouter(index);
                    });
                });
                
                document.querySelectorAll('.edit-router').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const index = parseInt(e.target.closest('button').dataset.index);
                        this.editRouter(index);
                    });
                });
                
                document.querySelectorAll('.router-item').forEach((item, index) => {
                    item.addEventListener('click', () => {
                        this.selectedRouterIndex = index;
                        this.updateRouterList();
                    });
                });
            }
            
            removeRouter(index) {
                this.routers.splice(index, 1);
                if (this.selectedRouterIndex >= index) {
                    this.selectedRouterIndex = this.routers.length > 0 ? 0 : -1;
                }
                this.updateRouterList();
                this.reset();
            }
            
            editRouter(index) {
                const router = this.routers[index];
                const newPower = parseFloat(prompt("Nova potência do roteador (0.5-2.0):", router.power));
                if (newPower && newPower >= 0.5 && newPower <= 2.0) {
                    router.power = newPower;
                    this.updateRouterList();
                    this.reset();
                    this.showToast(`${index+1} router power changed to ${newPower}`);
                }
            }
            
            toggleTheme() {
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                
                const themeToggle = document.getElementById('themeToggle');
                themeToggle.innerHTML = newTheme === 'dark' 
                    ? '<i class="fas fa-moon"></i>' 
                    : '<i class="fas fa-sun"></i>';
            }
            
            saveState() {
                // Salva o estado atual para histórico
                const state = {
                    walls: this.walls.map(row => [...row]),
                    wallMaterial: this.wallMaterial.map(row => [...row]),
                    routers: JSON.parse(JSON.stringify(this.routers)),
                    currentWallMaterial: this.currentWallMaterial,
                    wallThickness: this.wallThickness,
                    frequency: this.frequency,
                    power: this.power,
                    currentChannel: this.currentChannel
                };
                
                // Mantém apenas o histórico mais recente
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                this.history.push(state);
                this.historyIndex++;
                
                // Limita o tamanho do histórico
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }
            
            undo() {
                if (this.historyIndex <= 0) return;
                this.historyIndex--;
                this.applyState(this.history[this.historyIndex]);
                this.needsRedraw = true;
                this.showToast("Action undone");
            }
            
            redo() {
                if (this.historyIndex >= this.history.length - 1) return;
                this.historyIndex++;
                this.applyState(this.history[this.historyIndex]);
                this.needsRedraw = true;
                this.showToast("Action redone");
            }
            
            applyState(state) {
                this.walls = state.walls.map(row => [...row]);
                this.wallMaterial = state.wallMaterial.map(row => [...row]);
                this.routers = JSON.parse(JSON.stringify(state.routers));
                this.currentWallMaterial = state.currentWallMaterial;
                this.wallThickness = state.wallThickness;
                this.frequency = state.frequency;
                this.power = state.power;
                this.currentChannel = state.currentChannel;
                
                // Atualiza UI
                document.getElementById('current-material').textContent = 
                    this.materials[this.currentWallMaterial].name;
                document.getElementById('thicknessValue').textContent = this.wallThickness + 'px';
                document.getElementById('current-thickness').textContent = this.wallThickness + 'px';
                document.getElementById('power').value = this.power;
                document.getElementById('powerValue').textContent = this.power.toFixed(1);
                document.getElementById('frequency').value = this.frequency;
                document.querySelectorAll('.channel-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (parseInt(btn.dataset.channel) === this.currentChannel) {
                        btn.classList.add('active');
                    }
                });
                document.getElementById('current-channel').textContent = this.currentChannel;
                
                this.updateRouterList();
            }
            
            saveLayout() {
                const layout = {
                    walls: this.walls,
                    wallMaterial: this.wallMaterial,
                    routers: this.routers,
                    currentWallMaterial: this.currentWallMaterial,
                    wallThickness: this.wallThickness,
                    frequency: this.frequency,
                    power: this.power,
                    currentChannel: this.currentChannel
                };
                localStorage.setItem('wifiSimLayout', JSON.stringify(layout));
                this.showToast('Project saved successfully!');
            }
            
            loadLayout() {
                const savedLayout = localStorage.getItem('wifiSimLayout');
                if (savedLayout) {
                    try {
                        const layout = JSON.parse(savedLayout);
                        this.saveState();
                        this.applyState(layout);
                        this.needsRedraw = true;
                        this.showToast('Project loaded successfully!');
                    } catch (e) {
                        this.showToast('Error loading project. Invalid format.', 'error');
                    }
                } else {
                    this.showToast('No saved projects found.', 'error');
                }
            }
            
            saveAsImage() {
                const link = document.createElement('a');
                link.download = 'wifi-simulation.png';
                link.href = this.canvas.toDataURL();
                link.click();
                this.showToast('Image exported successfully!');
            }
            
            showHistory() {
                const historyList = document.getElementById('historyList');
                historyList.innerHTML = '';
                
                this.simulationHistory.slice().reverse().forEach((item, index) => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.innerHTML = `
                        <div><strong>${item.time}</strong></div>
                        <div>Cobertura: ${item.coverage}</div>
                        <div>Velocidade Média: ${item.avgSpeed}</div>
                        <div>Zonas Mortas: ${item.deadZones}</div>
                        <div>Roteadores: ${item.routers}</div>
                    `;
                    historyList.appendChild(historyItem);
                });
                
                document.getElementById('historyModal').style.display = 'flex';
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const gridX = Math.floor((x - this.offsetX) * this.Nx / (this.width * this.zoomLevel));
                const gridY = Math.floor((y - this.offsetY) * this.Ny / (this.height * this.zoomLevel));
                
                // Verificar se clicou em um roteador para arrastar
                if (this.currentTool !== 'router') {
                    for (let i = 0; i < this.routers.length; i++) {
                        const router = this.routers[i];
                        const dist = Math.sqrt(Math.pow(router.x - gridX, 2) + Math.pow(router.y - gridY, 2));
                        if (dist < 2) { // Raio de 2 células
                            this.draggingRouter = i;
                            this.canvas.style.cursor = 'grabbing';
                            return;
                        }
                    }
                }

                if (this.currentTool === 'router') {
                    if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                        this.saveState();
                        this.addRouter(gridX, gridY);
                        this.needsRedraw = true;
                    }
                    return;
                }
                
                if (this.currentTool === 'measure') {
                    this.measureStart = { x: gridX, y: gridY };
                    return;
                }
                
                if (e.button === 1 || (e.button === 0 && e.ctrlKey)) { // Botão do meio ou Ctrl + clique esquerdo
                    this.dragging = true;
                    this.dragStartX = e.clientX - this.offsetX;
                    this.dragStartY = e.clientY - this.offsetY;
                    this.canvas.style.cursor = 'grabbing';
                    return;
                }
                
                if (this.currentTool === 'rect') {
                    if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                        this.rectStart = { x: gridX, y: gridY };
                        this.isDrawingRect = true;
                    }
                    return;
                }
                
                if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                    this.saveState();
                    this.modifyWalls(gridX, gridY);
                    this.needsRedraw = true;
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Atualiza posição do cursor
                const gridX = Math.floor((x - this.offsetX) * this.Nx / (this.width * this.zoomLevel));
                const gridY = Math.floor((y - this.offsetY) * this.Ny / (this.height * this.zoomLevel));
                
                if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                    document.querySelector('.cursor-position').textContent = 
                        `Position: (${gridX}, ${gridY})`;
                }
                
                // Verificar se está sobre um roteador
                if (!this.dragging && !this.draggingRouter && !this.isDrawingRect && this.currentTool !== 'measure') {
                    let overRouter = false;
                    for (let i = 0; i < this.routers.length; i++) {
                        const router = this.routers[i];
                        const dist = Math.sqrt(Math.pow(router.x - gridX, 2) + Math.pow(router.y - gridY, 2));
                        if (dist < 2) {
                            overRouter = true;
                            break;
                        }
                    }
                    this.canvas.style.cursor = overRouter ? 'grab' : 'crosshair';
                }
                
                // Arrastar o canvas
                if (this.dragging) {
                    this.offsetX = e.clientX - this.dragStartX;
                    this.offsetY = e.clientY - this.dragStartY;
                    this.needsRedraw = true;
                    return;
                }
                
                // Arrastar roteador
                if (this.draggingRouter !== null) {
                    if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                        this.routers[this.draggingRouter].x = gridX;
                        this.routers[this.draggingRouter].y = gridY;
                        this.needsRedraw = true;
                    }
                    return;
                }
                
                // Medição
                if (this.currentTool === 'measure' && this.measureStart) {
                    this.measureEnd = { x: gridX, y: gridY };
                    this.updateMeasurement();
                    return;
                }
                
                // Preview de ferramenta
                this.updateToolPreview(gridX, gridY);
                
                // Desenhar com o mouse pressionado
                if (e.buttons === 1 && this.currentTool !== 'router' && this.currentTool !== 'rect' && this.currentTool !== 'measure') {
                    if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                        this.modifyWalls(gridX, gridY);
                        this.needsRedraw = true;
                    }
                }
                
                // Desenhar retângulo
                if (this.isDrawingRect && this.rectStart) {
                    this.drawRectPreview(gridX, gridY);
                }
            }
            
            handleMouseUp(e) {
                this.dragging = false;
                this.draggingRouter = null;
                this.canvas.style.cursor = 'crosshair';
                
                if (this.isDrawingRect) {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const gridX = Math.floor((x - this.offsetX) * this.Nx / (this.width * this.zoomLevel));
                    const gridY = Math.floor((y - this.offsetY) * this.Ny / (this.height * this.zoomLevel));
                    
                    if (gridX >= 0 && gridX < this.Nx && gridY >= 0 && gridY < this.Ny) {
                        this.saveState();
                        this.drawRectangle(this.rectStart.x, this.rectStart.y, gridX, gridY);
                        this.needsRedraw = true;
                    }
                    
                    this.isDrawingRect = false;
                    this.rectStart = null;
                }
                
                if (this.currentTool === 'measure' && this.measureStart) {
                    this.measureEnd = null;
                    this.showToolInfo("Medição concluída. Clique para nova medição");
                }
            }
            
            handleMouseWheel(e) {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const worldX = (x - this.offsetX) / this.zoomLevel;
                const worldY = (y - this.offsetY) / this.zoomLevel;
                
                if (e.deltaY < 0) {
                    this.zoomLevel *= (1 + zoomIntensity);
                } else {
                    this.zoomLevel *= (1 - zoomIntensity);
                }
                
                // Limitar zoom
                this.zoomLevel = Math.min(Math.max(0.5, this.zoomLevel), 3);
                
                // Ajustar offset para zoom no ponteiro do mouse
                this.offsetX = x - worldX * this.zoomLevel;
                this.offsetY = y - worldY * this.zoomLevel;
                
                this.needsRedraw = true;
            }
            
            zoom(factor) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                const worldX = (centerX - this.offsetX) / this.zoomLevel;
                const worldY = (centerY - this.offsetY) / this.zoomLevel;
                
                this.zoomLevel *= factor;
                
                // Limitar zoom
                this.zoomLevel = Math.min(Math.max(0.5, this.zoomLevel), 3);
                
                this.offsetX = centerX - worldX * this.zoomLevel;
                this.offsetY = centerY - worldY * this.zoomLevel;
                
                this.needsRedraw = true;
            }
            
            updateToolPreview(gridX, gridY) {
                const toolPreview = document.getElementById('toolPreview');
                
                if (this.currentTool === 'wall' || this.currentTool === 'erase' || this.currentTool === 'paint') {
                    const thickness = this.wallThickness;
                    const size = Math.max(10, thickness * 10 * this.zoomLevel);
                    
                    toolPreview.style.width = `${size}px`;
                    toolPreview.style.height = `${size}px`;
                    toolPreview.style.borderRadius = '50%';
                    
                    if (this.currentTool === 'wall') {
                        toolPreview.style.backgroundColor = this.materials[this.currentWallMaterial].color;
                    } else if (this.currentTool === 'erase') {
                        toolPreview.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
                    } else if (this.currentTool === 'paint') {
                        toolPreview.style.backgroundColor = this.materials[this.currentWallMaterial].color;
                        toolPreview.style.border = '2px dashed white';
                    }
                    
                    toolPreview.style.display = 'block';
                    toolPreview.style.left = `${e.clientX - size/2}px`;
                    toolPreview.style.top = `${e.clientY - size/2}px`;
                } else {
                    toolPreview.style.display = 'none';
                }
            }
            
            updateMeasurement() {
                if (!this.measureStart || !this.measureEnd) return;
                
                // Calcular distância em metros (considerando 1 célula = 0.5m)
                const dx = Math.abs(this.measureEnd.x - this.measureStart.x);
                const dy = Math.abs(this.measureEnd.y - this.measureStart.y);
                const distance = Math.sqrt(dx * dx + dy * dy) * 0.5;
                
                // Calcular posições na tela
                const startX = this.measureStart.x * this.dx * this.zoomLevel + this.offsetX;
                const startY = this.measureStart.y * this.dy * this.zoomLevel + this.offsetY;
                const endX = this.measureEnd.x * this.dx * this.zoomLevel + this.offsetX;
                const endY = this.measureEnd.y * this.dy * this.zoomLevel + this.offsetY;
                
                // Atualizar ou criar linha de medição
                if (!this.measureLine) {
                    this.measureLine = document.createElement('div');
                    this.measureLine.className = 'measure-line';
                    this.canvas.parentNode.appendChild(this.measureLine);
                    
                    this.measureDistance = document.createElement('div');
                    this.measureDistance.className = 'distance-indicator';
                    this.canvas.parentNode.appendChild(this.measureDistance);
                }
                
                // Atualizar linha
                const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
                
                this.measureLine.style.width = `${length}px`;
                this.measureLine.style.transform = `translate(${startX}px, ${startY}px) rotate(${angle}deg)`;
                
                // Atualizar indicador de distância
                this.measureDistance.textContent = `${distance.toFixed(1)} metros`;
                this.measureDistance.style.left = `${(startX + endX) / 2}px`;
                this.measureDistance.style.top = `${(startY + endY) / 2 - 20}px`;
            }
            
            clearMeasurement() {
                if (this.measureLine) {
                    this.measureLine.remove();
                    this.measureLine = null;
                }
                if (this.measureDistance) {
                    this.measureDistance.remove();
                    this.measureDistance = null;
                }
                this.measureStart = null;
                this.measureEnd = null;
            }
            
            drawRectPreview(endX, endY) {
                if (!this.rectStart) return;
                
                // Desenha preview do retângulo
                this.needsRedraw = true;
            }
            
            drawRectangle(startX, startY, endX, endY) {
                const minX = Math.min(startX, endX);
                const maxX = Math.max(startX, endX);
                const minY = Math.min(startY, endY);
                const maxY = Math.max(startY, endY);
                
                const materialCode = this.currentWallMaterial === 'concrete' ? 2 : 
                                   this.currentWallMaterial === 'wood' ? 3 :
                                   this.currentWallMaterial === 'brick' ? 4 :
                                   this.currentWallMaterial === 'glass' ? 5 : 1;
                
                for (let i = minX; i <= maxX; i++) {
                    for (let j = minY; j <= maxY; j++) {
                        if (i >= 0 && i < this.Nx && j >= 0 && j < this.Ny) {
                            this.walls[i][j] = true;
                            this.wallMaterial[i][j] = materialCode;
                        }
                    }
                }
            }
            
            modifyWalls(x, y) {
                const thickness = this.wallThickness;
                const halfThickness = Math.floor(thickness / 2);
                const materialCode = this.currentWallMaterial === 'concrete' ? 2 : 
                                   this.currentWallMaterial === 'wood' ? 3 :
                                   this.currentWallMaterial === 'brick' ? 4 :
                                   this.currentWallMaterial === 'glass' ? 5 : 1;
                
                for (let i = x - halfThickness; i <= x + halfThickness; i++) {
                    for (let j = y - halfThickness; j <= y + halfThickness; j++) {
                        if (i >= 0 && i < this.Nx && j >= 0 && j < this.Ny) {
                            if (this.currentTool === 'wall') {
                                this.walls[i][j] = true;
                                this.wallMaterial[i][j] = materialCode;
                            } else if (this.currentTool === 'erase') {
                                this.walls[i][j] = false;
                                this.wallMaterial[i][j] = 0;
                            } else if (this.currentTool === 'paint' && this.walls[i][j]) {
                                // Ferramenta de pintura: altera o material da parede existente
                                this.wallMaterial[i][j] = materialCode;
                            }
                        }
                    }
                }
            }
            
            toggleSimulation() {
                if (this.routers.length === 0) {
                    this.showToast('Please add at least one router!', 'error');
                    return;
                }
                
                this.running = !this.running;
                const btn = document.getElementById('playPause');
                btn.innerHTML = this.running ? '<i class="fas fa-pause"></i> Pause' : '<i class="fas fa-play"></i> Play';
                
                if (this.running) {
                    this.animate();
                }
            }
            
            reset() {
                this.running = false;
                document.getElementById('playPause').innerHTML = '<i class="fas fa-play"></i> Play';
                this.timeStep = 0;
                
                // Limpa campos
                for (let i = 0; i < this.Nx; i++) {
                    for (let j = 0; j < this.Ny; j++) {
                        this.Ez[i][j] = 0;
                        if (j < this.Ny - 1) this.Hx[i][j] = 0;
                        if (i < this.Nx - 1) this.Hy[i][j] = 0;
                    }
                }
                
                this.needsRedraw = true;
            }
            
            loadExampleApartment() {
                // Para primeiro se estiver rodando
                this.running = false;
                document.getElementById('playPause').innerHTML = '<i class="fas fa-play"></i> Play';
                
                // Limpa tudo
                this.saveState();
                this.reset();
                
                // Limpa paredes e materiais existentes
                for (let i = 0; i < this.Nx; i++) {
                    for (let j = 0; j < this.Ny; j++) {
                        this.walls[i][j] = false;
                        this.wallMaterial[i][j] = 0;
                    }
                }
                
                // Limpa roteadores
                this.routers = [];
                this.updateRouterList();
                
                // Planta baixa de apartamento 2 quartos (60m²)
                // Paredes externas (concreto)
                this.drawWallLine(15, 15, 145, 15, 'concrete');   // Parede superior
                this.drawWallLine(15, 145, 145, 145, 'concrete'); // Parede inferior  
                this.drawWallLine(15, 15, 15, 145, 'concrete');   // Parede esquerda
                this.drawWallLine(145, 15, 145, 145, 'concrete'); // Parede direita
                
                // Paredes internas (gesso acartonado - melhor transmissão)
                this.drawWallLine(15, 75, 60, 75, 'drywall');   // Divisão sala/cozinha
                this.drawWallLine(60, 45, 100, 45, 'drywall');  // Parede sala/corredor
                
                // Cozinha
                this.drawWallLine(100, 15, 100, 45, 'drywall');   // Parede vertical cozinha
                this.drawWallLine(60, 45, 60, 75, 'drywall');  // Parede cozinha/sala
                
                // Corredor central
                this.drawWallLine(60, 45, 60, 105, 'drywall');  // Parede corredor esquerda
                this.drawWallLine(100, 45, 100, 105, 'drywall');  // Parede corredor direita
                
                // Quartos (paredes internas)
                this.drawWallLine(15, 105, 60, 105, 'drywall');   // Parede superior quarto 1
                this.drawWallLine(37, 105, 37, 145, 'drywall');  // Divisão interna quarto 1
                this.drawWallLine(100, 105, 145, 105, 'drywall');  // Parede superior quarto 2
                this.drawWallLine(120, 105, 120, 145, 'drywall');  // Divisão interna quarto 2
                
                // Banheiros (paredes com cerâmica - maior absorção)
                this.drawWallLine(15, 120, 37, 120, 'concrete');   // Parede banheiro 1
                this.drawWallLine(60, 120, 100, 120, 'concrete');  // Parede banheiro 2 superior
                this.drawWallLine(80, 105, 80, 145, 'concrete');  // Divisão banheiro 2
                
                // Área de serviço
                this.drawWallLine(120, 15, 120, 37, 'drywall');   // Divisão área serviço
                
                // Janelas de vidro
                this.drawWallLine(15, 60, 15, 65, 'glass'); // Janela sala
                this.drawWallLine(145, 80, 145, 85, 'glass'); // Janela quarto 2
                
                // Posiciona roteadores
                this.addRouter(40, 60); // Sala
                this.addRouter(80, 80); // Corredor
                
                // Redesenha
                this.needsRedraw = true;
                
                // Feedback visual
                this.showToast('🏠 Sample project loaded! 2 bedroom apartment with routers in the living room and hallway.');
            }
            
            drawWallLine(x1, y1, x2, y2, materialType = 'drywall') {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = x1 < x2 ? 1 : -1;
                const sy = y1 < y2 ? 1 : -1;
                let err = dx - dy;
                let x = x1, y = y1;
                
                const materialCode = materialType === 'concrete' ? 2 : 
                                  materialType === 'wood' ? 3 :
                                  materialType === 'brick' ? 4 :
                                  materialType === 'glass' ? 5 : 1;
                
                while (true) {
                    if (x >= 0 && x < this.Nx && y >= 0 && y < this.Ny) {
                        this.walls[x][y] = true;
                        this.wallMaterial[x][y] = materialCode;
                        
                        // Adiciona espessura à parede
                        for (let i = -1; i <= 1; i++) {
                            for (let j = -1; j <= 1; j++) {
                                if (x+i >= 0 && x+i < this.Nx && y+j >= 0 && y+j < this.Ny) {
                                    this.walls[x+i][y+j] = true;
                                    this.wallMaterial[x+i][y+j] = materialCode;
                                }
                            }
                        }
                    }
                    
                    if (x === x2 && y === y2) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
            }
            
            showToast(message, type = 'success') {
                const toast = document.createElement('div');
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: 25px;
                    right: 25px;
                    background: ${type === 'error' ? 'linear-gradient(135deg, #e74c3c, #c0392b)' : 'linear-gradient(135deg, #2ecc71, #27ae60)'};
                    color: white;
                    padding: 18px 25px;
                    border-radius: 12px;
                    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                    z-index: 1000;
                    font-weight: bold;
                    max-width: 350px;
                    animation: slideIn 0.5s ease;
                `;
                
                if (!document.querySelector('#toastStyles')) {
                    const style = document.createElement('style');
                    style.id = 'toastStyles';
                    style.textContent = `
                        @keyframes slideIn {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        @keyframes slideOut {
                            from { transform: translateX(0); opacity: 1; }
                            to { transform: translateX(100%); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.5s ease';
                    setTimeout(() => toast.remove(), 500);
                }, 4000);
            }
            
            updateMagnetic() {
                // Atualiza Hx
                for (let i = 0; i < this.Nx; i++) {
                    for (let j = 0; j < this.Ny - 1; j++) {
                        this.Hx[i][j] -= this.chxe * (this.Ez[i][j + 1] - this.Ez[i][j]);
                    }
                }
                
                // Atualiza Hy
                for (let i = 0; i < this.Nx - 1; i++) {
                    for (let j = 0; j < this.Ny; j++) {
                        this.Hy[i][j] += this.chye * (this.Ez[i + 1][j] - this.Ez[i][j]);
                    }
                }
            }
            
            updateElectric() {
                // Atualização do campo elétrico com absorção realística de materiais
                for (let i = 1; i < this.Nx - 1; i++) {
                    for (let j = 1; j < this.Ny - 1; j++) {
                        // Calcula a atualização FDTD normal
                        const fieldUpdate = 
                            this.cezh * (this.Hy[i][j] - this.Hy[i - 1][j]) -
                            this.cezhy * (this.Hx[i][j] - this.Hx[i][j - 1]);
                        
                        // Aplica propriedades do material
                        let material = this.materials.air;
                        if (this.walls[i][j]) {
                            const matType = this.wallMaterial[i][j] === 2 ? 'concrete' : 
                                          this.wallMaterial[i][j] === 3 ? 'wood' :
                                          this.wallMaterial[i][j] === 4 ? 'brick' :
                                          this.wallMaterial[i][j] === 5 ? 'glass' : 'drywall';
                            material = this.materials[matType] || this.materials.drywall;
                        }
                        
                        // Atualiza campo com absorção
                        this.Ez[i][j] = this.Ez[i][j] * (1 - material.absorption) + fieldUpdate;
                        
                        // Transmissão através de paredes adjacentes
                        if (this.walls[i][j]) {
                            // Dentro da parede - aplica transmissão
                            this.Ez[i][j] *= material.transmission;
                            
                            // Efeito de transmissão de células adjacentes
                            let transmittedEnergy = 0;
                            let neighborCount = 0;
                            
                            // Verifica vizinhos e calcula energia transmitida
                            const neighbors = [[i-1,j], [i+1,j], [i,j-1], [i,j+1]];
                            for (let [ni, nj] of neighbors) {
                                if (ni >= 0 && ni < this.Nx && nj >= 0 && nj < this.Ny && !this.walls[ni][nj]) {
                                    transmittedEnergy += this.Ez[ni][nj] * material.transmission * 0.1;
                                    neighborCount++;
                                }
                            }
                            
                            if (neighborCount > 0) {
                                this.Ez[i][j] += transmittedEnergy / neighborCount;
                            }
                        } else {
                            // No ar livre - verifica absorção de paredes próximas
                            let nearWallAttenuation = 1.0;
                            const nearbyWalls = [[i-1,j], [i+1,j], [i,j-1], [i,j+1]];
                            
                            for (let [ni, nj] of nearbyWalls) {
                                if (ni >= 0 && ni < this.Nx && nj >= 0 && nj < this.Ny && this.walls[ni][nj]) {
                                    const matType = this.wallMaterial[ni][nj] === 2 ? 'concrete' : 
                                                  this.wallMaterial[ni][nj] === 3 ? 'wood' :
                                                  this.wallMaterial[ni][nj] === 4 ? 'brick' :
                                                  this.wallMaterial[ni][nj] === 5 ? 'glass' : 'drywall';
                                    const wallMat = this.materials[matType] || this.materials.drywall;
                                    nearWallAttenuation *= (1 - wallMat.reflection * 0.3); // Reflexão reduzida
                                }
                            }
                            
                            this.Ez[i][j] *= nearWallAttenuation;
                        }
                    }
                }
                
                // Adiciona fonte para cada roteador
                this.routers.forEach(router => {
                    if (router.x > 0 && router.x < this.Nx - 1 && 
                        router.y > 0 && router.y < this.Ny - 1) {
                        const signal = router.power * Math.sin(2 * Math.PI * router.frequency * this.timeStep);
                        this.Ez[router.x][router.y] += signal;
                    }
                });
            }
            
            animate() {
                if (!this.running) return;
                
                // Múltiplas iterações FDTD por frame para suavizar
                for (let iter = 0; iter < 3; iter++) {
                    this.updateMagnetic();
                    this.updateElectric();
                    this.timeStep++;
                }
                
                this.needsRedraw = true;
                this.updateStats();
                
                requestAnimationFrame(() => this.animate());
            }
            
            signalToSpeed(signal) {
                // Converte intensidade do sinal para velocidade estimada (Mbps)
                const maxSpeed = 1500; // WiFi 6 máximo teórico
                const k = 5; // Fator de sensibilidade
                
                // Modelo logístico para estimativa de velocidade
                return maxSpeed * (1 - Math.exp(-k * signal));
            }
            
            draw() {
                if (!this.needsRedraw && Date.now() - this.lastRender < this.renderInterval) {
                    return;
                }
                
                this.lastRender = Date.now();
                this.needsRedraw = false;
                
                // Limpa canvas
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Aplica transformações de zoom e pan
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.zoomLevel, this.zoomLevel);
                
                // Desenha campo elétrico (intensidade do sinal WiFi) convertido para velocidade
                const cellWidth = this.dx;
                const cellHeight = this.dy;
                
                for (let i = 0; i < this.Nx; i++) {
                    for (let j = 0; j < this.Ny; j++) {
                        const x = i * cellWidth;
                        const y = j * cellHeight;
                        
                        const signal = Math.min(Math.abs(this.Ez[i][j]) * 5, 1.0);
                        const speed = this.signalToSpeed(signal);
                        
                        if (this.walls[i][j]) {
                            // Diferentes cores para diferentes materiais
                            const material = this.wallMaterial[i][j];
                            let color = '#000000';
                            
                            if (material === 2) color = '#696969'; // Concreto
                            else if (material === 3) color = '#A0522D'; // Madeira
                            else if (material === 4) color = '#CD5C5C'; // Tijolo
                            else if (material === 5) color = '#87CEEB'; // Vidro
                            else color = '#8B4513'; // Gesso acartonado (padrão)
                            
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(x, y, cellWidth, cellHeight);
                        } else if (signal > 0.01) {
                            // Gradiente roxo (baixa velocidade) -> amarelo (alta velocidade)
                            // Normaliza a velocidade para o gradiente (0-1000 Mbps)
                            const normalizedSpeed = Math.min(speed / 1000, 1.0);
                            
                            // Interpolação entre #4b0082 (roxo escuro) e #ffd700 (amarelo)
                            const r = Math.floor(75 + (255 - 75) * normalizedSpeed);
                            const g = Math.floor(0 + (215 - 0) * normalizedSpeed);
                            const b = Math.floor(130 + (0 - 130) * normalizedSpeed);
                            
                            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                            this.ctx.fillRect(x, y, cellWidth, cellHeight);
                        }
                    }
                }
                
                // Desenha cada roteador
                this.routers.forEach(router => {
                    const x = router.x * cellWidth;
                    const y = router.y * cellHeight;
                    
                    this.ctx.fillStyle = router.color;
                    this.ctx.beginPath();
                    this.ctx.arc(x + cellWidth/2, y + cellHeight/2, cellWidth * 1.2, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Símbolo WiFi
                    this.ctx.strokeStyle = '#FFFFFF';
                    this.ctx.lineWidth = 2;
                    for (let r = 15; r <= 25; r += 5) {
                        this.ctx.beginPath();
                        this.ctx.arc(x + cellWidth/2, y + cellHeight/2, r, -Math.PI/4, -3*Math.PI/4, true);
                        this.ctx.stroke();
                    }
                });
                
                // Desenha preview do retângulo se estiver ativo
                if (this.isDrawingRect && this.rectStart) {
                    const startX = this.rectStart.x * cellWidth;
                    const startY = this.rectStart.y * cellHeight;
                    
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(startX, startY, (this.lastGridX - this.rectStart.x) * cellWidth, (this.lastGridY - this.rectStart.y) * cellHeight);
                }
                
                this.ctx.restore();
            }
            
            updateStats() {
                this.frameCount++;
                const now = Date.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = now;
                }
                
                // Calcula estatísticas
                let totalSignal = 0;
                let coveredCells = 0;
                let totalCells = 0;
                let deadZones = 0;
                let maxSpeed = 0;
                let totalSpeed = 0;
                this.deadZones = [];
                
                for (let i = 0; i < this.Nx; i++) {
                    for (let j = 0; j < this.Ny; j++) {
                        if (!this.walls[i][j]) {
                            totalCells++;
                            const signal = Math.abs(this.Ez[i][j]);
                            const speed = this.signalToSpeed(signal);
                            
                            totalSignal += signal;
                            totalSpeed += speed;
                            
                            if (speed > maxSpeed) maxSpeed = speed;
                            
                            if (signal > 0.01) {
                                coveredCells++;
                            } else {
                                deadZones++;
                                // Armazena zonas mortas para análise
                                if (this.deadZones.length < 10) {
                                    this.deadZones.push({x: i, y: j});
                                }
                            }
                        }
                    }
                }
                
                const coverage = totalCells > 0 ? (coveredCells / totalCells * 100).toFixed(1) : 0;
                const deadZonePct = totalCells > 0 ? (deadZones / totalCells * 100).toFixed(1) : 0;
                const avgSpeed = totalCells > 0 ? (totalSpeed / totalCells).toFixed(0) : 0;
                
                document.getElementById('timeStep').textContent = this.timeStep;
                document.getElementById('fps').textContent = this.fps;
                document.getElementById('coverage').textContent = coverage + '%';
                document.getElementById('avgSpeed').textContent = avgSpeed + ' Mbps';
                document.getElementById('maxSpeed').textContent = maxSpeed.toFixed(0) + ' Mbps';
                document.getElementById('deadZones').textContent = deadZonePct + '%';
                
                // Atualiza lista de zonas mortas
                const deadZoneList = document.getElementById('deadZoneList');
                deadZoneList.innerHTML = '';
                
                this.deadZones.forEach(zone => {
                    const zoneItem = document.createElement('div');
                    zoneItem.className = 'dead-zone-item';
                    zoneItem.textContent = `Zone (${zone.x}, ${zone.y}) - No signal`;
                    deadZoneList.appendChild(zoneItem);
                });
                
                if (this.deadZones.length === 0) {
                    const noZones = document.createElement('div');
                    noZones.className = 'dead-zone-item';
                    noZones.textContent = 'No significant dead zones detected';
                    deadZoneList.appendChild(noZones);
                }
                
                // Salva histórico de simulação
                if (this.running && this.timeStep % 100 === 0) {
                    this.simulationHistory.push({
                        time: new Date().toLocaleString(),
                        coverage: coverage + '%',
                        avgSpeed: avgSpeed + ' Mbps',
                        deadZones: deadZonePct + '%',
                        routers: this.routers.length
                    });
                    
                    // Limita histórico
                    if (this.simulationHistory.length > 50) {
                        this.simulationHistory.shift();
                    }
                    
                    localStorage.setItem('wifiSimHistory', JSON.stringify(this.simulationHistory));
                }
            }
        }
        
        // Inicializa simulador quando a página carregar
        window.addEventListener('load', () => {
            const simulator = new WiFiSimulator();
            
            // Inicializar histórico
            simulator.saveState();
            
            // Loop de renderização otimizado
            function renderLoop() {
                simulator.draw();
                requestAnimationFrame(renderLoop);
            }
            
            renderLoop();
        });
    </script>
</body>
</html>